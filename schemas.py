from __future__ import annotations
from enum import Enum
from typing import Dict, List, Literal, Optional, Tuple, Union, Any
from pydantic import BaseModel, Field, model_validator
from pathlib import Path
import tempfile
import soundfile as sf
import numpy as np
# =========================================
# Speaker Profile Data Model
# =========================================


class Relationship(BaseModel):
    with_speaker: str
    relationship_type: str
    evidence: str


class SpeakerProfile(BaseModel):
    speaker_id: str
    summary: str
    gender: Literal["male", "female", "unknown"] = Field(
        default="unknown",
        description="The gender of the speaker.",
    )
    gender_evidence: str = Field(
        description="The evidence supporting the    gender classification.",
    )
    role: Union[Literal["unknown"], str] = Field(
        default="unknown",
        description="The role of the speaker.",
    )
    role_evidence: str = Field(
        default="",
        description="The evidence supporting the role classification.",
    )
    relationships: List[Relationship] = Field(
        default_factory=list,
        description="List of relationships involving the speaker.",
    )


SpeakerProfile.model_rebuild()


# 1. Decomposer Output
class QueryIntent(BaseModel):
    """
    The structured intent of the user's query, extracted by the QueryDecomposer.
    """

    entities: List[str] = Field(
        ...,
        description="Key entities mentioned, such as speaker names, project codes, or specific locations.",
    )
    concepts: List[str] = Field(
        ...,
        description="Core concepts or topics the user is asking about, like 'budget concerns' or 'marketing strategy'.",
    )
    time_constraint: Optional[str] = Field(
        None,
        description="Any temporal constraints, e.g., 'in the last 5 minutes' or 'at the beginning of the meeting'.",
    )
    metadata_filter: Dict[str, Union[str, int]] = Field(
        default_factory=dict,
        description="Filters on metadata, like `{'speaker_id': 1}`.",
    )


# 2. Planner Output
class PlanStep(BaseModel):
    """
    A single step in the execution plan generated by the QueryPlanner.
    """

    tool_name: str = Field(..., description="The name of the tool or API to call.")
    args: Dict = Field(
        default_factory=dict, description="The arguments to pass to the tool."
    )
    thought: str = Field(
        ..., description="The reasoning for why this step is necessary."
    )


class ExecutionPlan(BaseModel):
    """
    The full execution plan, consisting of a series of steps.
    """

    plan: List[PlanStep]


# 4. Synthesizer Input
class Evidence(BaseModel):
    """
    A single piece of evidence retrieved by the ExecutionEngine.
    If audio data is provided, it will be automatically saved to a temporary file.
    """
    model_config = {"arbitrary_types_allowed": True}

    utterance_id: str
    transcript: str
    speaker_id: int
    time_range: Tuple[Optional[float], Optional[float]]
    source: str = Field(
        ..., description="The retrieval step that produced this evidence."
    )
    audio: Optional[Any] = Field(default=None, description="Audio data as numpy array")
    audio_path: Optional[str] = Field(default=None, description="Path to saved audio file")
    sample_rate: Optional[int] = Field(default=None, description="Audio sample rate")
    
    @model_validator(mode='after')
    def handle_audio_data(self):
        """
        Handle audio data bidirectionally:
        1. If audio_path is provided but audio is None, load audio from file
        2. If audio is provided but audio_path is None, save audio to file
        """
        # Case 1: Load audio from path if path exists but audio data is missing
        if self.audio_path is not None and self.audio is None:
            audio_file = Path(self.audio_path)
            if audio_file.exists():
                # Load audio data from file
                audio_data, sr = sf.read(str(audio_file), dtype='float32')
                self.audio = audio_data
                # Update sample_rate if not already set
                if self.sample_rate is None:
                    self.sample_rate = sr
        
        # Case 2: Save audio to file if audio data exists but path is missing
        elif self.audio is not None and self.audio_path is None:
            # Create temp directory if needed
            temp_dir = Path(tempfile.gettempdir()) / "audio_rag_evidence"
            temp_dir.mkdir(parents=True, exist_ok=True)
            
            # Generate file path
            audio_file = temp_dir / f"{self.utterance_id}.wav"
            
            # Determine sample rate (default to 16000 if not provided)
            sr = self.sample_rate if self.sample_rate is not None else 16000
            
            # Save audio data
            if isinstance(self.audio, np.ndarray):
                sf.write(str(audio_file), self.audio, sr)
                self.audio_path = str(audio_file)
        
        return self
    

# 5. Synthesizer Output
class Answer(BaseModel):
    """Structured answer with cited dialogue identifiers."""

    answer: str = Field(..., description="The synthesized answer to the user's query.")
    cite_conversation_ids: List[str] = Field(
        ..., description="List of dialogue identifiers cited in the answer."
    )


# 6. Reflection Output
class Reflection(BaseModel):
    """
    The output of the Reflection stage, judging the quality of the answer.
    """

    is_supported: bool = Field(
        ..., description="Whether the answer is fully supported by the evidence."
    )
    confidence_score: int = Field(
        ..., description="A score from 1 to 5 indicating confidence."
    )
    correction_needed: Optional[str] = Field(
        None,
        description="If not supported, a suggestion for what went wrong or what to do next.",
    )


if __name__ == "__main__":
    # Example usage and schema printing
    from rich import print

    print("QueryIntent Schema:")
    print(QueryIntent.model_json_schema())

    print("\nExecutionPlan Schema:")
    print(ExecutionPlan.model_json_schema())

    print("\nEvidence Schema:")
    print(Evidence.model_json_schema())

    print("\nAnswer Schema:")
    print(Answer.model_json_schema())

    print("\nReflection Schema:")
    print(Reflection.model_json_schema())
